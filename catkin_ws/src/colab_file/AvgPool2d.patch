--- /home/gauravp/anaconda2/envs/pytorch8/lib/python2.7/site-packages/torch/nn/modules/pooling.py
+++ /home/gauravp/anaconda2/envs/pytorch8/lib/python2.7/site-packages/torch/nn/modules/pooling.py
@@ -1,4 +1,4 @@
-class AvgPool2d(_AvgPoolNd):
+class AvgPool2d(Module):
     r"""Applies a 2D average pooling over an input signal composed of several input
     planes.
 
@@ -8,15 +8,13 @@
 
     .. math::
 
-        out(N_i, C_j, h, w)  = \frac{1}{kH * kW} \sum_{m=0}^{kH-1} \sum_{n=0}^{kW-1}
-                               input(N_i, C_j, stride[0] \times h + m, stride[1] \times w + n)
+        \begin{array}{ll}
+        out(N_i, C_j, h, w)  = 1 / (kH * kW) * \sum_{{m}=0}^{kH-1} \sum_{{n}=0}^{kW-1}
+                               input(N_i, C_j, stride[0] * h + m, stride[1] * w + n)
+        \end{array}
 
-    If :attr:`padding` is non-zero, then the input is implicitly zero-padded on both sides
-    for :attr:`padding` number of points.
-
-    Note:
-        When ceil_mode=True, sliding windows are allowed to go off-bounds if they start within the left padding
-        or the input. Sliding windows that would start in the right padded region are ignored.
+    | If :attr:`padding` is non-zero, then the input is implicitly zero-padded on both sides
+      for :attr:`padding` number of points
 
     The parameters :attr:`kernel_size`, :attr:`stride`, :attr:`padding` can either be:
 
@@ -30,20 +28,12 @@
         padding: implicit zero padding to be added on both sides
         ceil_mode: when True, will use `ceil` instead of `floor` to compute the output shape
         count_include_pad: when True, will include the zero-padding in the averaging calculation
-        divisor_override: if specified, it will be used as divisor, otherwise size of the pooling region will be used.
-
 
     Shape:
-        - Input: :math:`(N, C, H_{in}, W_{in})` or :math:`(C, H_{in}, W_{in})`.
-        - Output: :math:`(N, C, H_{out}, W_{out})` or :math:`(C, H_{out}, W_{out})`, where
-
-          .. math::
-              H_{out} = \left\lfloor\frac{H_{in}  + 2 \times \text{padding}[0] -
-                \text{kernel\_size}[0]}{\text{stride}[0]} + 1\right\rfloor
-
-          .. math::
-              W_{out} = \left\lfloor\frac{W_{in}  + 2 \times \text{padding}[1] -
-                \text{kernel\_size}[1]}{\text{stride}[1]} + 1\right\rfloor
+        - Input: :math:`(N, C, H_{in}, W_{in})`
+        - Output: :math:`(N, C, H_{out}, W_{out})` where
+          :math:`H_{out} = floor((H_{in}  + 2 * padding[0] - kernel\_size[0]) / stride[0] + 1)`
+          :math:`W_{out} = floor((W_{in}  + 2 * padding[1] - kernel\_size[1]) / stride[1] + 1)`
 
     Examples::
 
@@ -51,28 +41,28 @@
         >>> m = nn.AvgPool2d(3, stride=2)
         >>> # pool of non-square window
         >>> m = nn.AvgPool2d((3, 2), stride=(2, 1))
-        >>> input = torch.randn(20, 16, 50, 32)
+        >>> input = autograd.Variable(torch.randn(20, 16, 50, 32))
         >>> output = m(input)
     """
-    __constants__ = ['kernel_size', 'stride', 'padding', 'ceil_mode', 'count_include_pad', 'divisor_override']
 
-    kernel_size: _size_2_t
-    stride: _size_2_t
-    padding: _size_2_t
-    ceil_mode: bool
-    count_include_pad: bool
-
-    def __init__(self, kernel_size: _size_2_t, stride: Optional[_size_2_t] = None, padding: _size_2_t = 0,
-                 ceil_mode: bool = False, count_include_pad: bool = True, divisor_override: Optional[int] = None) -> None:
+    def __init__(self, kernel_size, stride=None, padding=0, ceil_mode=False,
+                 count_include_pad=True):
         super(AvgPool2d, self).__init__()
         self.kernel_size = kernel_size
-        self.stride = stride if (stride is not None) else kernel_size
+        self.stride = stride or kernel_size
         self.padding = padding
         self.ceil_mode = ceil_mode
         self.count_include_pad = count_include_pad
-        self.divisor_override = divisor_override
 
-    def forward(self, input: Tensor) -> Tensor:
+    def forward(self, input):
         return F.avg_pool2d(input, self.kernel_size, self.stride,
-                            self.padding, self.ceil_mode, self.count_include_pad, self.divisor_override)
+                            self.padding, self.ceil_mode, self.count_include_pad)
 
+    def __repr__(self):
+        return self.__class__.__name__ + '(' \
+            + 'kernel_size=' + str(self.kernel_size) \
+            + ', stride=' + str(self.stride) \
+            + ', padding=' + str(self.padding) \
+            + ', ceil_mode=' + str(self.ceil_mode) \
+            + ', count_include_pad=' + str(self.count_include_pad) + ')'
+